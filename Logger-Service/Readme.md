# ErrorLog Entity

## Overview
The `ErrorLog` entity is used to record error details that occur within the application. It captures the date and time of the error, a brief message, and a more detailed description.

## Fields
- `id`: A unique identifier for the error log entry, generated by a sequence.
- `date`: The date and time when the error occurred.
- `message`: A short message summarizing the error.
- `description`: A detailed description of the error.

## Usage
This entity can be used to log errors into a database, allowing for better tracking and management of application errors. It can be particularly useful for debugging and auditing purposes.

## Annotations
- `@Entity`: Specifies that this class is an entity and is mapped to a database table.
- `@Getter` and `@Setter`: Lombok annotations to generate the default getter and setter methods.
- `@Id`: Marks the `id` field as the primary key.
- `@GeneratedValue`: Configures the way of increment of the specified column(field).
- `@SequenceGenerator`: Defines a primary key generator that may be referenced by name when a generator element is specified for the `GeneratedValue` annotation.

## Example
An example usage of the `ErrorLog` entity might involve catching an exception and creating a new instance of `ErrorLog` with the relevant details, then persisting it to the database.


# ErrorLogRepository Interface

## Overview
The `ErrorLogRepository` interface extends the `JpaRepository` interface, providing a way to perform standard database operations on the `ErrorLog` entity. It leverages the capabilities of JPA to simplify data persistence.

## Usage
By extending `JpaRepository`, `ErrorLogRepository` inherits methods that allow for creating, reading, updating, and deleting `ErrorLog` records. It also provides methods for pagination and sorting.

## Methods
Some of the common methods available through `JpaRepository` that can be used with `ErrorLogRepository` include:
- `save`: Saves an `ErrorLog` entity and flushes changes instantly.
- `findById`: Retrieves an `ErrorLog` by its id.
- `findAll`: Returns all `ErrorLog` entries.
- `deleteById`: Deletes the `ErrorLog` with the given id.

## Custom Methods
You can also define custom methods within this interface to suit your specific needs, such as finding logs by message content or date ranges.

## Example
An example usage of `ErrorLogRepository` might involve injecting it into a service class and using it to log new errors or retrieve a list of existing errors for review.

# KafkaConsumerService

## Overview
The `KafkaConsumerService` class is responsible for consuming messages from Kafka topics and logging them into the system. It uses Spring's `@KafkaListener` annotation to define the topics it subscribes to and the methods that handle the incoming messages.

## Features
- **Error Log Consumption**: Listens to the `errorLog` topic and logs error messages.
- **Dead Letter Queue Handling**: Listens to the `errorLog.DLT` topic for messages that couldn't be processed and logs them as errors.
- **Info Log Consumption**: Listens to the `infoLog` topic and logs informational messages.

## Methods
- `consume`: Consumes messages from the `errorLog` topic and saves them as error logs.
- `consumeDLT`: Consumes messages from the `errorLog.DLT` topic, typically used for handling messages that failed to be processed correctly.
- `consumeInfos`: Consumes messages from the `infoLog` topic and saves them as info logs.

## Usage
Each method annotated with `@KafkaListener` is automatically invoked when a message is received on the configured topic. The service logs the start of the consumption process, creates a new `ErrorLog` entry with the current date and time, sets the message and description, and then saves the log entry using `ErrorLogRepository`. After saving the log, it logs the completion of the process.

## Dependencies
- Lombok: For logging and required argument handling.
- Spring Kafka: For integrating with Apache Kafka and consuming messages.

## Example
An example usage of `KafkaConsumerService` might involve deploying it as part of a microservice that needs to process various log messages from Kafka topics. It would automatically handle incoming messages and ensure they are logged appropriately in the system.

# KafkaConsumerConfig

## Overview
`KafkaConsumerConfig` is a configuration class that sets up Kafka consumers within a Spring application. It is annotated with `@Configuration` to indicate that it contains bean definitions, and `@EnableKafka` to enable detection of Kafka annotation-based listeners.

## Configuration Details

### KafkaTemplate
- **Autowired**: `KafkaTemplate<String, String>` is autowired to be used for publishing to topics, especially for dead-letter topics in case of errors.

### ConsumerFactory
- **Bean**: `consumerFactory` is a bean that creates a `ConsumerFactory` for Kafka consumers.
- **Properties**:
  - `BOOTSTRAP_SERVERS_CONFIG`: The Kafka bootstrap servers.
  - `GROUP_ID_CONFIG`: The consumer group ID.
  - `KEY_DESERIALIZER_CLASS_CONFIG`: The deserializer class for the key, which is `StringDeserializer`.
  - `VALUE_DESERIALIZER_CLASS_CONFIG`: The deserializer class for the value, which is `StringDeserializer`.

### KafkaListenerContainerFactory
- **Bean**: `kafkaListenerContainerFactory` is a bean that creates a `ConcurrentKafkaListenerContainerFactory`.
- **ConsumerFactory**: It sets the consumer factory to the one defined by `consumerFactory` bean.
- **ErrorHandler**: It configures a `CommonErrorHandler` to handle exceptions during consumption. This includes a `DeadLetterPublishingRecoverer` to send failed messages to a dead-letter topic and a `FixedBackOff` strategy with a 1000ms interval and a maximum of 3 attempts.

## Usage
This configuration is essential for setting up Kafka listeners in the application. It defines how Kafka messages are consumed and what happens in case of errors. The beans defined in this class are automatically picked up by the Spring container and used wherever necessary.

## Example
An example usage of `KafkaConsumerConfig` might involve listening to Kafka topics for messages and processing them within the application. If a message fails to be processed after three attempts, it will be sent to a dead-letter topic.
